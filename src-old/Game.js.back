
var CMD = {
	UP: 1,
	DOWN: 2,
	LEFT: 3,
	RIGHT: 4,
	MENU: 5,
	GAME_MENU: 6,
	ACTION_1: 7,
	ACTION_2: 8,
	ACTION_3: 9,
	ACTION_4: 10,
	ACTION_5: 11
}

var Direction = {
	FRONT: 1,
	FRONTUP: 2,
	FRONTDOWN: 3,
	BACK: 4,
	BACKUP: 5,
	BACKDOWN: 6,

	isFront: function(dir) {
		return dir <= 3;
	},

	isBack: function(dir) {
		return dir > 3;
	},

	opposite: function(dir) {
		switch (dir) {
			case this.FRONT: return this.BACK;
			case this.FRONTUP: return this.BACKDOWN;
			case this.FRONTDOWN: return this.BACKUP;
			case this.BACK: return this.FRONT;
			case this.BACKUP: return this.FRONTDOWN;
			case this.BACKDOWN: return this.FRONTUP;
		}
	}
}

class Dimension {
	constructor(width, height) {
		this.width = width;
		this.height = height;
	}
}

class Point {
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
}

class Cell {

	static WALL_H = '---';
	static WALL_V = ' | ';
	static DOOR_CLOSED = ' # ';
	static DOOR_OPEN = ' + ';
	static EMPTY = '.';
	static HERO = '@';

	constructor(ground, isWall = false, isHorWall = true) {
		this.isWall = isWall;
		this.collision = null;
		this.ground = ground;
		this.trigger = null;
		this.isHorWall = isHorWall;
	}

	show() {
		if (this.collision) {
			return this.collision.show();
		} else if(this.trigger){
			return this.trigger.show();
		} else if (this.isWall) {
			return this.isHorWall ? Cell.WALL_H : Cell.WALL_V;
		} else {
			return this.ground;
		}
	}

	canMove() {
		return !this.collision && !this.isWall;
	}
}

class Room {

	constructor(dim) {
		this.dimension = dim;
		this.map = [];
		for (let i = 0; i < dim.height; i++) {
			let show = [];
			for (let j = 0; j < dim.width; j++) {
				show.push(new Cell(Cell.EMPTY));
			}
			this.map.push(show);
		}
		this.doors = [];
		this.walls = {horizontal: [], vertical: []};
	}

	clear(){
		for (let i = 0; i < dim.height; i++) {
			for (let j = 0; j < dim.width; j++) {
				this.map[i][j] = null;
			}
		}
	}

	addBorderWalls(){
		this.putWallHorizontal(0);
		this.putWallHorizontal(this.dimension.height - 1);
		this.putWallVertical(0);
		this.putWallVertical(this.dimension.width - 1);
	}

	isAtBounds(position) {
		return position.x >= 0 && position.x < this.dimension.width &&
			position.y >= 0 && position.y < this.dimension.height;
	}

	canMoveTo(position) {
		let ret = this.isAtBounds(position) && this.map[position.y][position.x].canMove();
		return ret;
	}

	putCollision(element, position) {
		if (this.canMoveTo(position)) {
			this.map[position.y][position.x].collision = element;
			element.position.x = position.x;
			element.position.y = position.y;
			return true;
		} else {
			let other = this.map[position.y][position.x].collision;
			Unit.checkPair(element, other);
			return false;
		}
	}

	moveCollision(element, destination) {
		if (this.canMoveTo(destination)) {
			this.delCollision(element);
			return this.putCollision(element, destination);
		} else {
			let other = this.isAtBounds(destination) ? this.map[destination.y][destination.x].collision : null;
			Unit.checkPair(element, other);
			return false;
		}
	}

	delCollision(element) {
		let position = element.position;
		if (this.map[position.y][position.x].collision === element) {
			this.map[position.y][position.x].collision = null;
		}
	}

	createDoor(position, border) {
		if (this.isAtBounds(position)) {
			this.map[position.y][position.x].isWall = false;
			this.map[position.y][position.x].isHorWall = false;
			let door = new Door(position, this.game, border);
			this.map[position.y][position.x].trigger = door;
			this.doors.push(door);
			return door;
		}
	}

	putWallHorizontal(height){
		this.walls.horizontal.push(height);
		for(let i=0;i<this.dimension.width;i++){
			this.map[height][i].isWall = true;
			this.map[height][i].isHorWall = true;
		}
	}

	putWallVertical(width){
		this.walls.vertical.push(width);
		for(let i=0;i<this.dimension.height;i++){
			this.map[i][width].isWall = true;
			this.map[i][width].isHorWall = false;
		}
	}

	show(region){
		for (let i = region.y; i < region.y + region.height; i++) {
			let line = '';
			line += i % 2 == 0 ? '  ' : '';
			for (let j = region.x; j < region.x + region.width; j++) {
				let cell = this.map[i][j];
				if(cell){
					let c = cell.show();
					if(c.length === 3){
						line += c;
					} else {
						line += ' ' + c + ' ';
					}
				} else {
					line += '   ';
				}
				line += ' ';
			}
			line += i % 2 != 0 ? '  ': '';
			console.log(String(i).padStart(3, ' ') + line);
		}
		let line = '     ';
		for (let j = region.x; j < region.x + region.width; j++){
			let code = String.fromCharCode('A'.charCodeAt(0) + j) + ' ';
			if(j >= 26){
				code = String.fromCharCode('A'.charCodeAt(0) + (j % 26)) + (j % 26);
			}
			line += ' ' + code + ' ';
		}
		console.log(line);
	}
}

class MergeRooms {

	Border = {LEFT: 0, RIGHT: 1, UP: 2, DOWN: 3};

	constructor(dimension, room, position){
		this.dimension = dimension;
		this.startPosition = startPosition;
		this.room = new Room(dimension);
		this.room.clear();
		this.copyAtPosition(position,room);
		this.doors.inactive = [];

		for(let door of room.doors){
			
		}
	}
	
	copyAtPosition(room, position){
		for(let i=0;i<room.dimension.height;i++){
			for(let j=0;j<room.dimension.width;j++){
				this.room.map[i+position.x][j+position.y] = room.map[i][j];
			}
		}
	}

	addRoom(room, door, border){

	}







	calcRegion(room, door_position, border){
		let region = {x: 0, y: 0, width: room.dimension.width, height: room.dimension.height};
		switch(border){
			case this.Border.LEFT:
				region.width -= 1;
				region.x = door_position.x - region.width;
				break;
			case this.Border.RIGHT:
				region.width -= 1;
				region.x = door_position.x;
				break;
			case this.Border.UP:
				region.height -= 1;
				region.y = door_position.y - region.height;
				break;
			case this.Border.DOWN:
				region.height -= 1;
				region.y = door_position.y;
				break;
			default: return null;
		}
		return region;
	}

	canInsert(room, door_position, border){
		let region = calcRegion(room, door_position, border);
		if(region.x < 0 || region.x + region.width > this.room.dimension.width){
			return false;
		}
		if(region.y < 0 || region.y + region.height > this.room.dimension.height){
			return false;
		}
		for(let i=region.y;i<region.y + region.height;i++){
			for(let j=region.x;j<region.width + room.dimension.width;j++){
				let cell = room.map[i - region.y][j - region.x];
				if(cell){
					return false;
				}
			}
		}
		return true;
	}

	insert(position, room, border){

	}

	copyAtPosition(position, room, door){
		for(let i=0;i<room.dimension.height;i++){
			for(let j=0;j<room.dimension.width;j++){
				this.room.map[i+position.x][j+position.y] = room.map[i][j];
			}
		}
	}





	

	static copyAtPosition(position, source_room, dest_room){
		for(let i=0;i<source_room.dimension.height;i++){
			for(let j=0;j<source_room.dimension.width;j++){
				dest_room.map[i+position.x][j+position.y] = source_room.map[i][j];
			}
		}
	}

	static getBorder(source_room, source_door, dest_room, dest_door){
		if(source_door.position.x === 0 && dest_door.position.x === dest_room.dimension.width - 1){
			return MergeRooms.Border.LEFT;
		} else if(source_door.position.x === source_room.dimension.width - 1 && dest_door.position.x === 0){
			return MergeRooms.Border.RIGHT;
		} else if(source_door.position.y === 0 && dest_door.position.y === dest_room.dimension.height - 1){
			return MergeRooms.Border.UP;
		} else if(source_door.position.y === source_room.dimension.height - 1 && dest_door.position.y === 0){
			return MergeRooms.Border.DOWN;
		}
		return null;
	}

	static createMergeRoomVertical(source_room, source_door, dest_room, dest_door){
		if(dest_door.position.y < source_door.position.y){
			return createRoomMergeVertical(dest_room, dest_door, source_room, source_door);
		}
		let dim = new Dimension();
		dim.width = source_room.dimension.width + dest_room.dimension.width - 1;
		let diff = dest_door.position.y - source_door.position.y;
		if(diff + source_room.dimension.height > dest_room.dimension.height){
			dim.height = diff + source_room.dimension.height;
		} else {
			dim.height = dest_room.dimension.height;
		}
		return new Room(dim);
	}

	static mergeLeft(source_room, source_door, dest_room, dest_door){
		let room = createMergeRoomVertical(source_room, source_door, dest_room, dest_door);
		if(dest_door.position.y >= source_door.position.y){
			let merge_point = new Point();
			merge_point.x = dest_room.width - 1;
			merge_point.y = dest_door.position.y = source_door.position.y; 
			MergeRooms.copyAtPosition(merge_point, source_room, room);
			MergeRooms.copyAtPosition(new Point(0,0), dest_room, room);
		} else {
			let merge_point = new Point();
			merge_point.x = dest_room.width - 1;
			merge_point.y = 0;
			MergeRooms.copyAtPosition(merge_point, source_room, room);
			let start_point = new Point();
			start_point.x = 0;
			start_point.y = source_door.position.y - dest_door.position.y;
			MergeRooms.copyAtPosition(start_point, dest_room, room);
		}
		return room;
	}

	static mergeRight(source_room, source_door, dest_room, dest_door){
		let room = createMergeRoomVertical(source_room, source_door, dest_room, dest_door);
		if(dest_door.position.y >= source_door.position.y){
			MergeRooms.copyAtPosition(new Point(source_room.dimension.width - 1,0), dest_room, room);
			let merge_point = new Point();
			merge_point.x = 0;
			merge_point.y = dest_door.position.y = source_door.position.y; 
			MergeRooms.copyAtPosition(merge_point, source_room, room);
		} else {
			let start_point = new Point();
			start_point.x = source_room.dimension.width - 1;
			start_point.y = source_door.position.y - dest_door.position.y;
			MergeRooms.copyAtPosition(start_point, dest_room, room);
			let merge_point = new Point();
			merge_point.x = 0;
			merge_point.y = 0;
			MergeRooms.copyAtPosition(merge_point, source_room, room);
		}
		return room;
	}

	static mergeUp(source_room, source_door, dest_room, dest_door){
		let dim = new Dimension();
		dim.width = Math.max(source_room.dimension.x, dest_room.dimension.x);
		dim.height = source_room.dimension.y + dest_room.dimension.y -1;

		let room = new Room(dim);
		if(dest_door.position.y >= source_door.position.y){
			let merge_point = new Point();
			merge_point.x = 0;
			merge_point.y = dest_door.position.y = source_door.position.y; 
			MergeRooms.copyAtPosition(merge_point, source_room, room);
			// The destination door will be preserved (copy soruce then dest).
			MergeRooms.copyAtPosition(new Point(source_room.dimension.width - 1,0), dest_room, room);
		} else {
			let merge_point = new Point();
			merge_point.x = 0;
			merge_point.y = 0;
			MergeRooms.copyAtPosition(merge_point, source_room, room);
			let start_point = new Point();
			start_point.x = source_room.dimension.width - 1;
			start_point.y = source_door.position.y - dest_door.position.y;
			// The destination door will be preserved (copy soruce then dest).
			MergeRooms.copyAtPosition(start_point, dest_room, room);
		}
		return room;
	}

	static mergeDown(source_room, source_door, dest_room, dest_door){
	}

	static merge(source_room, source_door, dest_room, dest_door){
		let border = MergeRooms.getBorder(source_room, source_door, dest_room, dest_door);
		if(border === MergeRooms.Border.LEFT){
			return mergeLeft(source_room, source_door, dest_room, dest_door);
		} else if(border === MergeRooms.Border.RIGHT){
			return mergeRight(source_room, source_door, dest_room, dest_door);
		} else if(border === MergeRooms.Border.UP){
			return mergeUp(source_room, source_door, dest_room, dest_door);
		} else if(border === MergeRooms.Border.DOWN){
			return mergeDown(source_room, source_door, dest_room, dest_door);
		}
	}
}

class Door {

	constructor(position, game, border) {
		this.position = position;
		this.isOpen = false;
		this.game = game;
		this.border = border;
	}

	open() {
		this.isOpen = true;
		this.game.world.delCollision(this);
	}

	close() {
		this.isOpen = false;
		this.game.world.putCollision(this, this.position);
	}

	action() {
		if (this.isOpen) {
			close();
		} else {
			open();
		}
	}

	show() {
		return this.isOpen ? Cell.DOOR_OPEN : Cell.DOOR_CLOSED;
	}

	handleCollision(other) {

	}
}

class Unit {

	constructor(name, position) {
		this.name = name;
		this.position = position;
		this.direction = Direction.FRONT;
	}

	changeDirection(direction) {
		let changeToBack = Direction.isFront(direction) && Direction.isBack(this.direction);
		let changeToFront = Direction.isBack(direction) && Direction.isFront(this.direction);
		if (changeToBack || changeToFront) {
			this.direction = Direction.opposite(this.direction);
			return true;
		}
		return false;
	}

	moveTo(direction) {
		if (this.changeDirection(direction)) {
			return;
		}

		let nextPosition = { x: this.position.x, y: this.position.y };
		switch (direction) {
			case Direction.FRONT: nextPosition.x += 1; break;
			case Direction.FRONTUP:
				nextPosition.x += this.position.y % 2 == 0 ? 1 : 0;
				nextPosition.y -= 1;
				break;
			case Direction.FRONTDOWN:
				nextPosition.x += this.position.y % 2 == 0 ? 1 : 0;
				nextPosition.y += 1;
				break;
			case Direction.BACK: nextPosition.x -= 1; break;
			case Direction.BACKUP:
				nextPosition.x -= this.position.y % 2 == 0 ? 0 : 1;
				nextPosition.y -= 1;
				break;
			case Direction.BACKDOWN:
				nextPosition.x -= this.position.y % 2 == 0 ? 0 : 1;
				nextPosition.y += 1;
				break;
		}

		this.game.world.moveCollision(this, nextPosition);
	}

	processCommand(cmd) {
		switch (cmd) {
			case CMD.RIGHT: this.moveTo(Direction.FRONT); break;
			case CMD.LEFT: this.moveTo(Direction.BACK); break;
			case CMD.UP:
				if (Direction.isFront(this.direction)) {
					this.moveTo(Direction.FRONTUP);
				} else {
					this.moveTo(Direction.BACKUP);
				}
				break;
			case CMD.DOWN:
				if (Direction.isFront(this.direction)) {
					this.moveTo(Direction.FRONTDOWN);
				} else {
					this.moveTo(Direction.BACKDOWN);
				}
				break;
		}
	}

	show() {
		return Direction.isFront(this.direction) ? " " + Cell.HERO + ">" : "<" + Cell.HERO + " ";
	}

	handleCollision(other) {

	}

	static checkPair(a, b) {
		if (a) a.handleCollision(b);
		if (b) b.handleCollision(a);
	}
}

class Camera {

	constructor(visible, anchor) {
		this.dimension = null;
		this.visible = visible;
		this.anchor = anchor;
	}

	getRegion() {
		let region = { x: 0, y: 0, width: this.visible.width, height: this.visible.height };
		let min = { x: Math.floor(this.visible.width / 2), y: Math.floor(this.visible.height / 2) };
		let max = { x: this.dimension.width - Math.floor(this.visible.width / 2),
			y: this.dimension.height - Math.floor(this.visible.height / 2) };
		if (this.dimension.width > this.visible.width) {
			if (this.anchor.x >= min.x && this.anchor.x < max.x) {
				region.x = this.anchor.x - Math.floor(this.visible.width / 2);
			} else if (this.anchor.x >= max.x) {
				region.x = this.dimension.width - this.visible.width;
			}
		} else {
			region.width = this.dimension.width;
		}
		if (this.dimension.height > this.visible.height) {
			if (this.anchor.y >= min.y && this.anchor.y < max.y) {
				region.y = this.anchor.y - Math.floor(this.visible.height / 2);
			} else if (this.anchor.y >= max.y) {
				region.y = this.dimension.height - this.visible.height;
			}
		} else {
			region.height = this.dimension.height;
		}
		return region;
	}
}

class Game {

	constructor() {
		this.camera = new Camera(new Dimension(30, 50));
	}

	start() {
		this.instance = this;
		let msg = '1. New Game\n' + '2. Continue\n' + '3. Settings\n' + '4. Exit\n:';
		let readlineSync = require('readline-sync');
		//let opt = readlineSync.questionInt(msg);
		let opt = 1;
		switch (opt) {
			case 1:
				let room = new Room(new Dimension(20, 20));
				room.addBorderWalls();
				this.setRoom(room);
				room.createDoor(new Point(0, 5));
				room.createDoor(new Point(5, 0));
				let hero = new Unit("Hero", new Point(2, 2));
				this.setHero(hero);
				this.listenInput();
		}
	}

	listenInput() {
		var keypress = require('keypress');

		// make `process.stdin` begin emitting "keypress" events
		keypress(process.stdin);

		let current = this;
		// listen for the "keypress" event
		process.stdin.on('keypress', function(ch, key) {
			current.cmd = null;
			if (key) {
				switch (key.name) {
					case 'up': current.cmd = CMD.UP; break;
					case 'down': current.cmd = CMD.DOWN; break;
					case 'left': current.cmd = CMD.LEFT; break;
					case 'right': current.cmd = CMD.RIGHT; break;
					case 'space': current.cmd = CMD.MENU; break;
					case 'escape': current.cmd = CMD.GAME_MENU; break;
				}
			} else {
				switch (ch) {
					case 1: current.cmd = CMD.ACTION_1; break;
					case 2: current.cmd = CMD.ACTION_2; break;
					case 3: current.cmd = CMD.ACTION_3; break;
					case 4: current.cmd = CMD.ACTION_4; break;
					case 5: current.cmd = CMD.ACTION_5; break;
				}
			}
			if (key && key.ctrl && key.name == 'c') {
				process.stdin.pause();
			} else {
				current.update();
			}
		});

		process.stdin.setRawMode(true);
		process.stdin.resume();
		this.show();
	}

	setHero(hero) {
		this.hero = hero;
		hero.game = this;
		let res = this.world.putCollision(hero, hero.position);
		this.camera.anchor = this.hero.position;
		console.assert(res, 'Can not put hero at position!');
	}

	setRoom(room) {
		this.world = room;
		this.camera.dimension = room.dimension;
		room.game = this;
	}

	processCommand() {
		switch (this.cmd) {
			case CMD.GAME_MENU: break;
			case CMD.MENU: break;
		}
		this.hero.processCommand(this.cmd);
	}

	update() {
		process.stdin.pause();
		this.processCommand();
		//console.clear();
		this.show();
		this.cmd = null;
		process.stdin.resume();
	}

	show(){
		let region = this.camera.getRegion();
		this.world.show(region);
	}
}



new Game().start();

